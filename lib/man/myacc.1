.ie t .ds St "\v'.3m'\s+2*\s-2\v'-.3m'
.el .ds St *
.ds lB "/u/lib
.TH MYACC 1 "local:Stanglow"
.SH NAME
myacc \- LALR(1) parser generator for Modula-2
.SH SYNOPSIS
.B myacc
.RB [ \(emvrelkKtbld "] [" \(emo modname]
.RB [ -W dir]
grammar
.SH DESCRIPTION
.I Myacc
is an LALR(1) parser generator that
has been developed
from
.IR yacc (1).
From a grammar containing definitions, rules, actions
and additional Modula-2-text
.I myacc
constructs a complete parser written in Modula-2.
.LP
Basically
.I myacc
has the same capabilities
than
.I yacc ,
even if
some changes in the declaration
part were necessary
to reflect the specific demands
of
Modula-2.
In comparison to
.I yacc
some additional features have
been added
to improve error handling of the created parser.
.LP
.I Myacc
supports
following options:
.IP -v  
generate a verbose file that contains a detailed description of 
the parser, the specification of all conflicts and
some informal statistics.
.IP -t
cause the constructed parser to trace syntax analysis
.IP -r 
rename the suffix of the generated definition module from .d to .dy.
May be used to
prevent
.IR make (1)
from recompilation
of dependent modules in those cases
the contents of the parser definition module has not changed.
.IP -k 
keep (do not delete) output files. By default all output files
are removed if things go wrong.
.IP -K
keep (do not delete) any file. This option applies also to all
temporary files generated by
.IR myacc.
.TP
.B -b
invokes
.IR m2b (1)
as output filter.
May be helpful for debugging and a beforehand
syntax check of actions.
.TP
.B -e
enable parser to issue detailed error messages (see below)
.TP
.B -l
cause the parser to read its tables from a data file
instead of assigning the values element wise during initialization.
This option seriously reduces the compilation and loading time of the parser
and should be used for every non trivial application.
.TP
.BR -o []modname
make
.I modname
the name of the output modules.
All filenames are built by concatenating
.I modname
and a
suitable suffix (see below for details).
Since this option takes effect on all files created
more than one
.I myacc
may be active on a directory.
Default
.I modname
is 'Myacc'.
.TP
.BR -W []dir
specify the directory
.I dir
where the parser will
find its data
file.
Requested only
if the parser and data file
are installed on different
directories.
.IP grammar
input file
.SH GRAMMAR FORMAT
Identifiers and single character constants must match
the Modula-2 format.
Comments reach from
.B (\*(St
to 
.B \*(St)
and may be nested.
Keywords and character-sequences of special meaning are always
headed by
.BR '%'
and do not contain any space
characters.
.LP
Input files to
.I myacc
are separated by
.BR %% -marks
into
a (optional)
declaration section,
the grammar rules
and some additional Modula-2-text
(in the following always referred as
ANY).
.TP
.I grammar
:
.RI [ declarations ]
.B %% 
.I rules
.RB [ %% " ANY]
.SH DECLARATIONS
.TP
.BR %imports " ANY"
the following text up to the next
myacc keyword is copied into implementation
.I and 
definition module of the parser.
Intended to enable import of objects that are used within both
modules (f.i. types used for value stack definition).
Should be used only once in a grammar and must precede
any other declaration expect
.B %init
(see below).
.TP
.BR %defs " ANY"
the following text up to the next myacc keyword
is copied into definition module.
Can be used to export objects declared within the parser.
.TP
.BR %{ " ANY " %}
the text between the two marks is
copied into implementation module. Intended for definition of
constants, types, variables and procedure.
The first
.BR %{
ANY
.BR %}
in a grammar file may also contain
import statements.
.LP
.B %case
.I variant
{
.B ;
.I variant
}
.B %end
.br
.RS
defines the type of value stack elements
as a case variant record.
Each
.I variant
must be specified
.RS
.I identifier
.B :
.I simpletype
.RE
where
.I simpletype
is a Modula-2
identifier designating the
type of a variant.
.RE
.LP
The following declarations
have
exactly the same semantic
as the corresponding declarations
of
.IR yacc ,
but follow a slightly modified
syntax.
.I Myacc
will not recognize other
keywords than those listed.
Please note
that
.I typename
always refers to the
left hand side of a
variant
in the
.BR %case .. %end -construction.
Single character constants
.RI ( char )
may be specified
octal
or as a string of length one.
.LP
.B %token
[\c
.BI < typename >\c
]
.I
.RI ( identifier | char )
.RI { identifier | char }
.RS
Definition of terminal symbols and their value type.
Character constants (which need not not to be declared)
may appear to determine their type.
.RE
.LP
.ta \w'\f3%right\fP'u
.B "%left	"
[\c
.BI < typename >\c
]
.I
.RI ( identifier | char )
.RI { identifier | char }
.br
.B "%right	"
[\c
.BI < typename >\c
]
.I
.RI ( identifier | char )
.RI { identifier | char }
.br
.B "%non	"
[\c
.BI < typename >\c
]
.I
.RI ( identifier | char )
.RI { identifier | char }
.ta
.RS
Define precedence table for
terminal symbols with the indicated
associativity. These definitions do not require
a previous
.BR %token -definition.
.RE
.LP
.B %type
.BI < typename >
.RI ( identifier | char )
.RI { identifier | char }
.RS
Value type definition for the listed grammar symbols.
.RE
.TP
.BI %start " identifier"
Outstand the starting symbol of grammar,
which is
by default
the left hand side of the first
rule.
.LP
The following both declarations are intended to support
keyword recognition.
.LP
.B %keyword
[\c
.BI < typename >\c
]
.I identifier
.RI { identifier }
.RS
Same effect for language recognition that
a
.BR %token -definition.
The listed tokens are marked as keywords.
.RE
.TP
.BR %init " [\f2module\fP" \&. "] " \f2procedure\fP
Defines
.IR module . procedure 
to be called
for any keyword 
during initialization phase of the parser.
The expected procedure head is
.RI ( Keywords . DefineKey
could be used):
.br
.DS
   PROCEDURE procedure (keywordtext : ARRAY OF CHAR;
      tokenvalue : INTEGER);
.DE
.br
.B %init
must not be preceded by nothing else that a
.BR %imports -definition.
.SH RULES AND ACTIONS
Besides some lexical aspects already mentioned
there are no differences
between
.I yacc
and 
.I myacc
concerning
syntax and semantic
of
rules and actions:
.TP
.B error
is a reserved
token name for error handling.
.TP
.B %prec
is available to decide ambiguities by precedence of operators (tokens).
.TP
.BR { " ANY " }
represents an action
.LP
.BR $ [ <\c
.IB typename >\c
.RB ][ \(em ]\c
.I number
.RS
within an action refers to the value of
the corresponding grammar symbol,
.B $$
to the non terminal symbol on left hand side of the rule.
.RE
.TP
.B ;
is the optional end of rule mark
.SH PROGRAM TEXT
.I Myacc
is unable to
check syntax or semantic
of Modula-2 program text.
The following remarks should be noticed
to avoid problems when compiling the
parser:
.LP
Internally used names are
introduced by
.B yy .
.LP
All objects declared by the user
are global to the module.
Statements must be part of a procedure.
Initialization of global variables can be
realized as an action
of the first
(empty) rule.
.LP
Actions must contain nothing else but legal
statement sequences.
.LP
The output files contain
line number information
for debugging of compilation errors.
.ta
.SH PARSER INTERFACE
A definition module created by
.I myacc
will (more or less) look like this:
.DS
TYPE 
   YYSTYPE = 
      RECORD 
         CASE : CARDINAL OF 
         | 1 : 
               var1 : type1;
         | 2 : 
               var2 : type2;
         END 
      END;

(* Token definitions *)

CONST 
   token1 = 257;
   token2 = 258;
   (* ... *)

VAR 
   yylval : YYSTYPE;

PROCEDURE yyparse() : INTEGER;

PROCEDURE yytoktext(tok : INTEGER; 
   VAR text : ARRAY OF CHAR);

CONST 
   YYERRCODE = 256;

TYPE 
   YYTOKSET = SET OF [0..511];

VAR 
   yylex  : PROCEDURE () : INTEGER;
   yyerror: PROCEDURE (
      (* errorno:    *) INTEGER,       (* no. of error  *)
      (* line:       *) INTEGER,       (* -1 if unknown *)
      (* col:        *) INTEGER,       (* -1 if unknown *)
      (* errortoken: *) INTEGER,    (*illegal input sym.*)
      (* errortext:  *) ARRAY OF CHAR, (* "" if unknown *)
      (* expected:   *) YYTOKSET);     (* empty without *)
                                       (* -e option     *)
   yytext : POINTER TO CHAR;
   yyline : POINTER TO CARDINAL;
   yycol  : POINTER TO CARDINAL;
.DE
.LP
.I YYSTYPE
defines the type of value stack.
The case variants result from
the
.BR %case -definition.
.LP
The input symbols to be recognized
by lexical analysis
are defined as
constants.
Their names are equal to those
used in
the token definitions
of the input grammar.
Occasionally
.I Myacc
adds
the suffix
.B sy
to avoid conflicts with predefined Modula-2 names.
.LP
.I yyparse
executes syntax analysis,
repeatly
calling
.I yylex
to obtain the
next symbol from input stream.
A suitable procedure
has to be assigned to
.I yylex
outside the parser module.
.I yyparse
expects
this procedure to
return:
.IP \(em
the ascii-value of a single input character
.IP \(em
one of the constant defined above if the corresponding token is recognized
.IP \(em
a value less or
equal
zero if the end of input is reached
.IP \(em
.I YYERRCODE
if an illegal lexical symbol is detected
.LP
.I yylval
is the value
associated with the current
input symbol and
must be set by the lexical analyzer.
.LP
.I yyparse
returns
.B 0
on successful completion of syntax
analysis,
.B -1
in case of an unrecovered syntax error
and a value < 
.B -1
if parsing tables could not be loaded.
.LP
.I yytoktext
yields a printable
.I text
for any token
.I tok.
.LP
Any syntax error
will cause
.I yyparse
to call
.IR yyerror 
no matter if the error is recovered or not.
.I Myacc
assigns a default
error handling routine
to
.IR yyerror \&,
that will receive the indicated arguments
from the parser.
By default
.IR
.I yyparse
provides information
about the illegal symbol
('errortoken') and the consecutive number
('errorno')
of the error
currently treated.
If
.I myacc
was called
with option
.B \(eme
a set
of legal input symbols
('expected')
will be computed
as well.
Information about position
('line', 'col') and text
('errortext') 
of erroneous input symbols
are available
only
if
.IR yyparse
can dereference
.IR yyline ,
.I yycol
and
.I yytext .
(i.e. if these pointers have been assigned
to the address of variables that hold these
information).
.SH ERROR HANDLING
The default error handling reports syntax errors
to
.IR StdIO . stderr .
The messages will contain all information
currently available to
.IR yyparse
(see above):
.LP .1v
.DS
[syntax error in line 1] near identifier 'a' (column 1). Expected:
                         token1 token2 token3 
.DE
.LP
Of course
the set of legal input symbols
created by
.I yyparse
(option
.B \(eme
required)
depends on the current parsing state.
It will contain
all tokens listed
in the verbose file
as legal input symbols
to cause a shift or
reduce action of the parser.
.LP
Legal input symbols tend to hide
behind the
default parsing actions
marked
.B $else
in the
verbose file
.RI ( yacc
outputs
.BR \&. instead).
.I Myacc
cannot include these symbols
into the set of expected tokens,
but adding some
more
.B error
tokens into the grammar rules
may uncover them.
.SH PREDEFINED PROCEDURES
.DS
PROCEDURE yyclearin();

PROCEDURE yyerrorok();

PROCEDURE yyreset();

PROCEDURE yyexit (exitcode : INTEGER);

PROCEDURE yyshowerror(yyno, yyline, yycol, yybad : INTEGER;
   yytext : ARRAY OF CHAR; yyexpected : YYTOKSET);
.DE
.LP
The procedures listed above
are available
within actions:
.I yyclearin
and
.I yyclearok
have the same meaning than the
corresponding
macros
of
.IR yacc \&,
.I yyreset 
resets the initial parser state
and
.I yyexit
terminates syntax analysis
with
.I exitcode
returned by
.I yyparse
as the result of syntax analysis.
.I yyshowerror
is the
the default error handling routine
of any parser created by
.I myacc .
.SH DIAGNOSTICS
Errors in input file
are reported to
.I stderr .
The number of detected shift/reduce and reduce/reduce-conflicts
are issued the same way.
A specification of all
conflicts can be obtained from the
verbose file
if
option
.B \(emv
is used.
.SH SEE ALSO
.IR yacc (1),
.IR Keywords (3MOD),
.LP
With the exception of the language dependent features
any description of
.I yacc
applies
for
.I myacc
accordingly.
Thus you may refer to the following
references for an introduction
into usage
of
.IR myacc :
.LP
A. T. Schreiner & H. G. Friedman, Jr.
.br
.I "Introduction to Compiler Construction with UNIX"
.br
Prentice-Hall 1985.
.br
A German translation is available as well (Hanser 1985).
.LP
Stephen C. Johnson
.br
.I "Yacc: Yet Another Compiler-Compiler"
.br
Programmers Workbench (Edition VII)
.LP
.SH FILES
.ta \w'\*(lB/myaccpar  'u
.IR Myacc ".m2	parser implementation module"
.br
.IR Myacc ".d	parser definition module"
.br
.IR Myacc ".dy	parser definition module (option \f3\(emr\fP)"
.br
.IR Myacc ".t	parsing tables (option \f3\(eml\fP)"
.br
.IR Myacc ".out	verbose file (option \f3\(emv\fP)"
.br
.IR Myacc ".act	temporary"
.br
.IR Myacc ".dat	temporary"
.br
.IR Myacc ".loc	temporary"
.br
.IR Myacc ".tmp	temporary"
.br
\*(lB/myaccpar	parser skeleton
.ta
.SH BUGS
Unfortunately
.I myacc
has inherited
from yacc
not only
the capabilities
but some bugs as well:
.LP
Error messages issued by
.I myacc
are intended to
be self-explanatory but sometimes they are
not.
.LP
Ambiguous declarations will not be recognized in 
any case.
.LP
.I Myacc
does not care
about whether the types
presented
in a
.BI < typename >\c
-construction 
are legal or not.
.LP
Unterminated actions tend to produce cascades
of error messages
(the last line will indicate their beginning).
.LP
If things go wrong
.I myacc
occasionally
complains about
non existing streams
it cannot close.
These messages should be ignored.
.LP
Option
.B \(emb
should be used only
if the
input grammar
is accepted by
.IR  myacc 
without a fatal error message.
